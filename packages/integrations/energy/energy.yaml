# Created by Danny Tsang <danny@tsang.uk>
automation:
  # Notifications
  - id: "1661076689668"
    alias: "Energy: Battery Charged And Forecasted Excess Solar"
    description: ""
    trigger:
      - platform: numeric_state
        entity_id: sensor.growatt_sph_battery_state_of_charge
        above: input_number.battery_charged_notification
    condition:
      - condition: or
        conditions:
          - condition: numeric_state
            entity_id: sensor.total_solar_forecast_estimated_energy_production_this_hour
            above: "0"
          - condition: numeric_state
            entity_id: sensor.total_solar_forecast_estimated_energy_production_next_hour
            above: "0"
      - not:
          - condition: state
            entity_id: sensor.growatt_sph_inverter_mode
            state: "Battery first"
      - alias: Not from an unknown state before
        condition: template
        value_template: "{{ trigger.from_state.state != 'unknown'}}"
    action:
      - service: script.energy_notify_excess_solar
        data: {}
    mode: single
  - id: "1660858653319"
    alias: "Energy: Solar Forecast Tomorrow"
    description: ""
    trigger:
      - platform: time
        at: "21:00:00"
    condition: []
    action:
      - alias: update forecast
        service: script.update_solcast
        data: {}
      - parallel:
          - if:
              - condition: numeric_state
                entity_id: sensor.total_solar_forecast_estimated_energy_production_tomorrow
                below: input_number.solar_generation_minimum_threshold
            then:
              - service: script.send_to_home_log
                data:
                  message: >-
                    Forecast generation is expected to be low
                    ({{ states('sensor.total_solar_forecast_estimated_energy_production_tomorrow') }}<
                    {{ states('input_number.solar_generation_minimum_threshold', with_unit=True) }}).

                    Incrementing counter from {{ states('input_number.consecutive_forecast_days_below_solar_generation') }} to
                    {{ (states('input_number.consecutive_forecast_days_below_solar_generation')|int(0)) + 1 }}
                    {{ state_attr('input_number.consecutive_forecast_days_below_solar_generation', 'unit_of_measurement') }}.
                  title: ":sunny: :zap: Solar"
                  log_level: "Normal"
              - service: input_number.increment
                data: {}
                target:
                  entity_id: input_number.consecutive_forecast_days_below_solar_generation
            else:
              - service: input_number.set_value
                data:
                  value: 0
                target:
                  entity_id: input_number.consecutive_forecast_days_below_solar_generation
          - service: script.energy_notify_tomorrows_solar_forecast
            data: {}
    mode: single
  - id: "1664743590782"
    alias: "Energy: Battery Charged Today"
    description: ""
    trigger:
      - platform: numeric_state
        entity_id: sensor.growatt_sph_battery_state_of_charge
        above: input_number.growatt_battery_charged_threshold
    condition:
      - condition: state
        entity_id: input_boolean.battery_charged_today
        state: "off"
    action:
      - service: script.send_to_home_log
        data:
          message: Battery charged today
          title: ":sunny: :zap: Solar"
          log_level: "Debug"
      - service: input_boolean.turn_on
        data: {}
        target:
          entity_id: input_boolean.battery_charged_today
      - if:
          - condition: numeric_state
            entity_id: input_number.consecutive_days_battery_not_charged
            above: 0
        then:
          - service: script.send_to_home_log
            data:
              message: Resetting days not fully charged.
              title: ":sunny: :zap: Solar"
              log_level: "Debug"
          - service: input_number.set_value
            data:
              value: 0
            target:
              entity_id: input_number.consecutive_days_battery_not_charged
    mode: single
  - id: "1664743700827"
    alias: "Energy: Reset Battery Charged Today"
    description: ""
    trigger:
      - platform: time
        at: "00:00:00"
    condition: []
    action:
      - choose:
          - conditions:
              - condition: state
                entity_id: input_boolean.battery_charged_today
                state: "on"
            sequence:
              - parallel:
                  - service: script.send_to_home_log
                    data:
                      message: Resetting battery charged today.
                      title: ":sunny: :zap: Solar"
                      log_level: "Debug"
                  - service: input_boolean.turn_off
                    data: {}
                    target:
                      entity_id: input_boolean.battery_charged_today
          - conditions:
              - condition: state
                entity_id: input_boolean.battery_charged_today
                state: "off"
            sequence:
              - service: script.send_to_home_log
                data:
                  message: >-
                    Battery did not fully charge today
                    (> {{ states('input_number.growatt_battery_charged_threshold', with_unit=True) }}).
                    Adding a day to count
                    ({{ states('input_number.consecutive_days_battery_not_charged') }}).
                  title: ":sunny: :zap: Solar"
                  log_level: "Debug"
              - service: input_number.increment
                data: {}
                target:
                  entity_id: input_number.consecutive_days_battery_not_charged
    mode: single
  - id: "1663589154517"
    alias: "Energy: Solar Production exceed threshold"
    description: ""
    trigger:
      - platform: numeric_state
        entity_id: sensor.total_solar_forecast_estimated_energy_production_today
        above: input_number.solar_generation_minimum_threshold
    condition: []
    action:
      - service: script.send_to_home_log
        data:
          message: Production above threshold. Resetting Forecast
          title: ":sunny: :zap: Solar"
          log_level: "Debug"
    mode: single
  - id: "1664744505278"
    alias: "Energy: Consecutive Days Battery Not Charged"
    description: ""
    trigger:
      - platform: numeric_state
        entity_id: input_number.consecutive_days_battery_not_charged
        above: 6
    condition: []
    action:
      - service: script.send_direct_notification
        data:
          message:
            It has been {{ states('input_number.consecutive_days_battery_not_charged')
            }} days where the battery has not been charged fully.
          title: ":sunny: :zap: Solar"
          people:
            entity_id:
              - person.danny
    mode: single
  - id: "1663588514009"
    alias: "Energy: Consecutive Low Solar Generation"
    description: ""
    trigger:
      - platform: numeric_state
        entity_id: input_number.consecutive_forecast_days_below_solar_generation
        above: 6
    condition: []
    action:
      - service: script.send_direct_notification
        data:
          message:
            It has been {{ states('input_number.consecutive_forecast_days_below_solar_generation')
            }} days with low solar generation.
          title: ":sunny: :zap: Solar"
          people:
            entity_id:
              - person.danny
    mode: single
  - id: "1674508693884"
    alias: "Energy: Battery Charge Notification"
    description: Used for Demand Flexibility Service
    trigger:
      - platform: time
        at: "15:55:00"
    condition:
      - condition: template
        value_template: "{{ (states('sensor.growatt_sph_battery_state_of_charge')|int(0)) >
        ((states('number.growatt_sph_load_first_stop_discharge')|int(0)) + 1) }}"
    action:
      - service: script.send_direct_notification
        data:
          message: >-
            {{ states('sensor.growatt_sph_battery_state_of_charge') }}%
            (That is {{ state_attr('sensor.battery_charge_remaining_hours', 'duration') }}) remaining.
          title: ":house_with_garden: :battery: House Battery"
          people:
            entity_id:
              - person.danny
    mode: single
  - id: "1704121569476"
    alias: "Energy: Low Battery Before Peak Time"
    description: "TODO: Make this dynmaic"
    trigger:
      - platform: time
        at: "14:00:00"
      - platform: time
        at: "15:00:00"
    condition:
      - condition: template
        value_template: >-
          {{ today_at("19:00") < as_datetime(states('sensor.battery_charge_remaining_hours')) }}
      - not:
        - condition: state
          entity_id: sensor.growatt_sph_inverter_mode
          state: "Battery first"
    action:
      - service: script.send_direct_notification
        data:
          message: >-
            Battery will not last beyond 19:00 today
            ({{ as_datetime(states('sensor.battery_charge_remaining_hours')) }}).
            Consider charging the battery.
          title: Solar
          people:
            entity_id: person.danny
    mode: single
  - id: "1680444237958"
    alias: "Energy: Power Cut Notification"
    description: ""
    trigger:
      - platform: state
        entity_id:
          - sensor.growatt_sph_load_power
        to: "0"
        for:
          hours: 0
          minutes: 1
          seconds: 0
    condition: []
    action:
      - service: script.send_direct_notification
        data:
          message:
            No electricty consumption detected for over a minute. Check for power
            cut.
          title: ":warning: :zap: :house_with_garden: House :warning:"
    mode: single
  - id: "1712404842177"
    alias: "Energy: High Grid Power Draw"
    description: ""
    trigger:
      - platform: numeric_state
        entity_id:
          - sensor.house_current
        above: sensor.grid_max_import_power_warning
    condition: []
    action:
      - service: script.send_direct_notification
        metadata: {}
        data:
          message: >-
            Current draw is close to cut out fuse
            ({{ (states('sensor.grid_max_import_power_warning')|float(0))|round(2) }}/{{ states('input_number.cut_out_fuse_size') }}).
            Consider turning devices off.
          title: "Energy: House"
          people:
            entity_id:
              - person.danny
              - person.terina
    mode: single
  # Octopus
  - id: "1719079836561"
    alias: "Energy: Join Energy Saver Session"
    description: ""
    trigger:
      - platform: state
        entity_id:
          - event.octopus_energy_octoplus_saving_session_events
    condition:
      - condition: template
        value_template: >-
          {{ state_attr(trigger.entity_id, 'available_events') | length > 0 }}
    action:
      - service: octopus_energy.join_octoplus_saving_session_event
        data:
          event_code: "{{ state_attr(trigger.entity_id, 'available_events')[0]['code'] }}"
        target:
          entity_id: event.octopus_energy_octoplus_saving_session_events
      - service: script.send_direct_notification
        metadata: {}
        data:
          message: >-
            Joined Energy Saver Session code {{ state_attr(trigger.entity_id, 'available_events')[0]['code'] }}
          title: Energy
          people:
            entity_id:
              - person.danny
    mode: single
  - id: "1719080490915"
    alias: "Energy: Saving Session Started"
    description: ""
    trigger:
      - platform: state
        entity_id:
          - binary_sensor.octopus_energy_octoplus_saving_sessions
        not_from: "unavailable"
        to: "on"
    condition: []
    action:
      - service: script.send_direct_notification
        metadata: {}
        data:
          message: Energy Saver Session Started
          title: Energy
          people:
            entity_id:
              - person.danny
              - person.terina
    mode: single
  - id: "1719080490916"
    alias: "Energy: Saving Session Finished"
    description: ""
    trigger:
      - platform: state
        entity_id:
          - binary_sensor.octopus_energy_octoplus_saving_sessions
        not_from: "unavailable"
        to: "off"
    condition: []
    action:
      - service: script.send_direct_notification
        metadata: {}
        data:
          message: Energy Saver Session Finished
          title: Energy
          people:
            entity_id:
              - person.danny
              - person.terina
    mode: single

conversation:
  intents:
    getBatteryLevel:
      - "[How much] battery is left"
      - "[What is the] (battery|charge) (level|remaining)"
    getBatteryRunTime:
      - "How long will the battery last [for]"
      - "How long will the battery run [for]"
      - "[What is the] battery (run time|runtime|hour|hours)"
      - "When will the battery run out"
    getBatterySummary:
      - "Battery summary"
    getChargingScheduleSummary:
      - "[What] [is the] charging schedule [summary]"
      - "[How] [is the] charging schedule [set]"
    getCurrentElectricityRates:
      - "[What is the current] [electricity] [unit] (rate|rates)"
    getExportSchedule:
      - "[What] [is the] export schedule"
    getInverterMode:
      - "[What is the] inverter mode"
    getNextElectricityRates:
      - "[What is the] next [electricity] [unit] (rate|rates)"
    getPreviousElectricityRates:
      - "[What was the] (old|previous|last) [electricity] [unit] (rate|rates)"
    getSolarForecastLeft:
      - "[How much] solar [generation is] (left|remaining) [today]"
      - "Remaining solar [generation] [forecast] [today]"
    getSolarForecastToday:
      - "[What is the] solar forecast today"
    getSolarForecastTomorrow:
      - "[What is the] solar forecast"
    getSolarGeneratedToday:
      - "[How much] solar [has] [generated|created] [today|so far]"

intent_script:
  getBatteryLevel:
    speech:
      text: >-
        {{ states('sensor.growatt_sph_battery_state_of_charge', with_unit=True) }}
  getBatteryRunTime:
    speech:
      text: >-
        {{ states('sensor.battery_charge_remaining_hours') }}
  getBatterySummary:
    speech:
      text: >-
        {{ states('sensor.growatt_sph_battery_state_of_charge', with_unit=True) }}
        and will run out in {{ states('sensor.battery_charge_remaining_hours') }}
  getChargingScheduleSummary:
    speech:
      text: >-
        Charging schedule summary:


        Cost nothing: {{ states('input_boolean.solar_assistant_charge_electricity_cost_nothing') }}

        Cost below nothing: {{ states('input_boolean.solar_assistant_charge_electricity_cost_below_nothing') }}


        Octopus rate: {{ states('input_boolean.charge_octopus_schedule') }}

        Forecast Based: {{ states('input_boolean.enable_forecast_based_charging') }}


        Below export: {{ states('input_boolean.enable_permanent_charge_below_export') }}

        Below export schedule: {{ states('group.below_export_charging_schedules') }}
        {% if states('group.below_export_charging_schedules') == 'on' %}
        {% for s in state_attr('group.below_export_charging_schedules', 'entity_id') -%}
        {% if states(s) == 'on' %}
        # {{ state_attr(s, 'friendly_name') }}
        from: {{ as_timestamp(state_attr('binary_sensor.charge_below_export_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'after'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        to: {{ as_timestamp(state_attr('binary_sensor.charge_below_export_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'before'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        next start: {{ as_timestamp(state_attr('binary_sensor.charge_below_export_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'next_update'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        {% endif %}
        {%- endfor -%}
        {%- endif -%}

        Battery first schedule: {{ states('group.battery_first_charging_schedules') }}
        {% if states('group.battery_first_charging_schedules') == 'on' %}
        {% for s in state_attr('group.battery_first_charging_schedules', 'entity_id') -%}
        {% if states(s) == 'on' %}
        # {{ state_attr(s, 'friendly_name') }}
        from: {{ as_timestamp(state_attr('binary_sensor.battery_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'after'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        to: {{ as_timestamp(state_attr('binary_sensor.battery_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'before'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        next start: {{ as_timestamp(state_attr('binary_sensor.battery_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'next_update'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        {% endif %}
        {%- endfor -%}
        {%- endif -%}


        Grid first schedule: {{ states('group.grid_first_charging_schedules') }}
        {% if states('group.grid_first_charging_schedules') == 'on' %}
        {% for s in state_attr('group.grid_first_charging_schedules', 'entity_id') -%}
        {% if states(s) == 'on' %}
        # {{ state_attr(s, 'friendly_name') }}
        from: {{ as_timestamp(state_attr('binary_sensor.grid_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'after'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        to: {{ as_timestamp(state_attr('binary_sensor.grid_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'before'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        next start: {{ as_timestamp(state_attr('binary_sensor.grid_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'next_update'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        {% endif %}
        {%- endfor -%}
        {%- endif -%}


        Maintain charge schedule: {{ states('group.maintain_battery_first_charging_schedules') }}
        {% if states('group.maintain_battery_first_charging_schedules') == 'on' %}
        {% for s in state_attr('group.maintain_battery_first_charging_schedules', 'entity_id') -%}
        {% if states(s) == 'on' %}
        # {{ state_attr(s, 'friendly_name') }}
        from: {{ as_timestamp(state_attr('binary_sensor.maintain_charge_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'after'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        to: {{ as_timestamp(state_attr('binary_sensor.maintain_charge_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'before'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        next start: {{ as_timestamp(state_attr('binary_sensor.maintain_charge_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'next_update'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        {% endif %}
        {%- endfor -%}
        {%- endif -%}
  getCurrentElectricityRates:
    speech:
      text: >-
        {{ states('sensor.electricity_current_rate')|float(0)|round(2) }}
        {{ state_attr('sensor.electricity_current_rate', 'unit_of_measurement') }}.
  getExportSchedule:
    speech:
      text: >-
        Grid first schedule: {{ states('group.grid_first_charging_schedules') }}
        {% if states('group.grid_first_charging_schedules') == 'on' %}
        {% for s in state_attr('group.grid_first_charging_schedules', 'entity_id') -%}
        {% if states(s) == 'on' %}
        # {{ state_attr(s, 'friendly_name') }}
        from: {{ as_timestamp(state_attr('binary_sensor.grid_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'after'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        to: {{ as_timestamp(state_attr('binary_sensor.grid_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'before'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        next start: {{ as_timestamp(state_attr('binary_sensor.grid_first_schedule_' ~ s.split('_')[s.split('_')|length - 1], 'next_update'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }}
        {% endif %}
        {%- endfor -%}
        {%- endif -%}
  getInverterMode:
    speech:
      text: >-
        {{ states('sensor.growatt_sph_inverter_mode') }}
  getNextElectricityRates:
    speech:
      text: >-
        {{ states('sensor.electricity_next_rate')|float(0)|round(2) }}
        {{ state_attr('sensor.electricity_next_rate', 'unit_of_measurement') }}.
  getPreviousElectricityRates:
    speech:
      text: >-
        {{ states('sensor.electricity_previous_rate')|float(0)|round(2) }}
        {{ state_attr('sensor.electricity_previous_rate', 'unit_of_measurement') }}.
  getSolarForecastLeft:
    speech:
      text: >-
        {{ (states('sensor.total_solar_forecast_estimated_energy_production_today')|float(0) - states('sensor.growatt_sph_pv_energy')|float(0))|round(2) }}
        {{ state_attr('sensor.growatt_solar_generated_energy_today', 'unit_of_measurement') }} remaining.
  getSolarForecastToday:
    speech:
      text: >-
        Today's forecast is
        {{ states('sensor.total_solar_forecast_estimated_energy_production_today', with_unit=True) }}.
  getSolarForecastTomorrow:
    speech:
      text: >-
        Tomorrow's forecast is
        {{ states('sensor.total_solar_forecast_estimated_energy_production_tomorrow', with_unit=True) }}.
  getSolarGeneratedToday:
    speech:
      text: >-
        {{ states('sensor.growatt_solar_generated_energy_today', with_unit=True) }}

group:
  battery_first_charging_schedules:
    name: "Battery First Charging Schedules"
    entities:
      - input_boolean.enable_battery_first_schedule_1
      - input_boolean.enable_battery_first_schedule_2
  below_export_charging_schedules:
    name: "Battery First Charging Schedules"
    entities:
      - input_boolean.enable_charge_below_export_schedule_1
      - input_boolean.enable_charge_below_export_schedule_2
      - input_boolean.enable_charge_below_export_schedule_3
  grid_first_charging_schedules:
    name: "Grid First Charging Schedules"
    entities:
      - input_boolean.enable_grid_first_schedule_1
  maintain_battery_first_charging_schedules:
    name: "Maintain Battery First Charging Schedules"
    entities:
      - binary_sensor.maintain_charge_first_schedule_1
      - binary_sensor.maintain_charge_first_schedule_2

script:
  todays_solar_forecast_data:
    alias: Today's Solar Forecast Data
    sequence:
      - service: weather.get_forecasts
        target:
          entity_id: weather.home
        data:
          type: daily
        response_variable: weather
      - variables:
          forecast: >-
            {#- If Forecast.io is unavailable, fallback to Forecast.io -#}
            {%- if states('sensor.total_solar_forecast_estimated_energy_production_today') not in ('unavailable', 'unknown') -%}
            {{ states('sensor.total_solar_forecast_estimated_energy_production_today')|float(0) }}
            {%- else -%}
            {{ states('sensor.solcast_pv_forecast_forecast_today')|float(0) }}
            {%- endif -%}
          forecast_source: >-
            {%- if states('sensor.total_solar_forecast_estimated_energy_production_tomorrow') not in ('unavailable', 'unknown') -%}
            Forecast.io
            {%- else -%}
            Solcast
            {%- endif -%}
          last_changed: >-
            {#- If Solcast is unavailable, fallback to Forecast.io -#}
            {%- if states('sensor.solcast_pv_forecast_forecast_today') not in ('unavailable', 'unknown') -%}
            {{ states.sensor.solcast_pv_forecast_forecast_today.last_changed }}
            {%- else -%}
            {{ states.sensor.total_solar_forecast_estimated_energy_production_today.last_changed }}
            {%- endif -%}
          estimate_charge_percentage_based_on_solar: >-
            {%- from 'charge_battery_amount.jinja' import calculate_charge_battery_amount -%}
            {{ calculate_charge_battery_amount(forecast) }}
          estimate_charge_kwh_based_on_solar: >-
            {{ (states('input_number.solar_battery_size')|float(0)
            *(1-(states('number.growatt_sph_load_first_stop_discharge')|float(0)/100)))
            *(estimate_charge_percentage_based_on_solar|float(0)/100) }}
          estimate_charge_hours_based_on_solar: >-
            {{ (states('input_number.solar_battery_size')|float(0)
            *(1-(states('number.growatt_sph_load_first_stop_discharge')|float(0)/100)))
            *(estimate_charge_percentage_based_on_solar|float(0)/100)
            / states('input_number.solar_battery_max_charge_rate')|float(0) }}
          weather_compensation_ratio: >-
            {%- from 'charge_battery_amount.jinja' import weather_compensation_ratio -%}
            {{ weather_compensation_ratio(weather['weather.home'].forecast[1].condition) }}
          estimate_charge_percentage: >-
            {{ estimate_charge_percentage_based_on_solar }}
          estimate_charge_kwh: >-
            {{ estimate_charge_kwh_based_on_solar }}
          estimate_charge_hours: >-
            {{ estimate_charge_hours_based_on_solar }}
          solar_forecast_data: >-
            {{
              {
              'estimate_charge_percentage': estimate_charge_percentage|round(2),
              'estimate_charge_kwh': estimate_charge_kwh|round(2),
              'charge_hours': estimate_charge_hours|round(2),
              'charge_hours_rounded': (estimate_charge_hours * 2)|round(0, 'ceil')/2,
              'weather_condition': ""~weather['weather.home'].forecast[1].condition~"",
              'weather_temperature': weather['weather.home'].forecast[1].temperature,
              'weather_compensation_ratio': weather_compensation_ratio,
              'last_changed': ""~last_changed~""
              }
            }}
      - stop: "Stop running the rest of the sequence"
        response_variable: "solar_forecast_data"
  tomorrows_solar_forecast_data:
    alias: Tomorrow's Solar Forecast Data
    sequence:
      - service: weather.get_forecasts
        target:
          entity_id: weather.home
        data:
          type: daily
        response_variable: weather
      - variables:
          forecast: >-
            {#- If Forecast.io is unavailable, fallback to solcast -#}
            {%- if states('sensor.total_solar_forecast_estimated_energy_production_tomorrow') not in ('unavailable', 'unknown') -%}
            {{ states('sensor.total_solar_forecast_estimated_energy_production_tomorrow')|float(0) }}
            {%- else -%}
            {{ states('sensor.solcast_pv_forecast_forecast_tomorrow')|float(0) }}
            {%- endif -%}
          forecast_source: >-
            {%- if states('sensor.total_solar_forecast_estimated_energy_production_tomorrow') not in ('unavailable', 'unknown') -%}
            Forecast.io
            {%- else -%}
            Solcast
            {%- endif -%}
          last_changed: >-
            {#- If Solcast is unavailable, fallback to Forecast.io -#}
            {%- if states('sensor.solcast_pv_forecast_forecast_tomorrow') not in ('unavailable', 'unknown') -%}
            {{ states.sensor.solcast_pv_forecast_forecast_tomorrow.last_changed }}
            {%- else -%}
            {{ states.sensor.total_solar_forecast_estimated_energy_production_tomorrow.last_changed }}
            {%- endif -%}
          estimate_charge_percentage_based_on_solar: >-
            {%- from 'charge_battery_amount.jinja' import calculate_charge_battery_amount -%}
            {{ calculate_charge_battery_amount(forecast) }}
          estimate_charge_kwh_based_on_solar: >-
            {{ (states('input_number.solar_battery_size')|float(0)
            *(1-(states('number.growatt_sph_load_first_stop_discharge')|float(0)/100)))
            *(estimate_charge_percentage_based_on_solar|float(0)/100) }}
          estimate_charge_hours_based_on_solar: >-
            {{ (states('input_number.solar_battery_size')|float(0)
            *(1-(states('number.growatt_sph_load_first_stop_discharge')|float(0)/100)))
            *(estimate_charge_percentage_based_on_solar|float(0)/100)
            / states('input_number.solar_battery_max_charge_rate')|float(0) }}
          weather_compensation_ratio: >-
            {%- from 'charge_battery_amount.jinja' import weather_compensation_ratio -%}
            {{ weather_compensation_ratio(weather['weather.home'].forecast[1].condition) }}
          estimate_charge_percentage: >-
            {{ estimate_charge_percentage_based_on_solar }}
          estimate_charge_kwh: >-
            {{ estimate_charge_kwh_based_on_solar }}
          estimate_charge_hours: >-
            {{ estimate_charge_hours_based_on_solar }}
          solar_forecast_data: >-
            {{
              {
              'generation_forecast': forecast,
              'generation_forecast_unit_of_measurement': ""~'kWh'~"",
              'generation_forecast_source': ""~forecast_source~"",
              'estimate_charge_percentage': estimate_charge_percentage|round(2),
              'estimate_charge_kwh': estimate_charge_kwh|round(2),
              'charge_hours': estimate_charge_hours|round(2),
              'charge_hours_rounded': (estimate_charge_hours * 2)|round(0, 'ceil')/2,
              'weather_condition': ""~weather['weather.home'].forecast[1].condition~"",
              'weather_temperature': weather['weather.home'].forecast[1].temperature,
              'weather_compensation_ratio': weather_compensation_ratio,
              'last_changed': ""~last_changed~""
              }
            }}
      - stop: "Stop running the rest of the sequence"
        response_variable: "solar_forecast_data"
  energy_notify_tomorrows_solar_forecast:
    alias: Energy Notify Tomorrow's Solar Forecast
    variables:
      avg_hourly_energy_usage: >-
        {%- if states('input_select.home_mode')|lower == 'holiday' -%}
        {{ states('sensor.home_electricity_power_daily_average_over_a_day')|float(1) }}
        {%- else -%}
        {{ states('sensor.home_electricity_power_daily_average_over_a_week')|float(1) }}
        {%- endif -%}
    sequence:
      - service: script.tomorrows_solar_forecast_data
        response_variable: solar_forecast_data
      - service: script.send_direct_notification
        data:
          message: >-
            {%- from 'emoji.jinja' import get_weather -%}
            Tommorow's ({{ (as_timestamp(now()) - (24*3600)) | timestamp_custom('%Y-%m-%d', True) }})
            weather is {{ get_weather(solar_forecast_data.weather_condition, 'Slack') }} with a generation of
            {{ solar_forecast_data.generation_forecast|float(0)|round(2) }}
            {{ solar_forecast_data.generation_forecast_unit_of_measurement }}
            {#- If Solcast is unavailable, fallback to Forecast.io -#}
            {% if states('sensor.solcast_pv_forecast_forecast_tomorrow') not in ('unavailable', 'unknown') %}
            {%- from 'get_solar_forecast.jinja' import get_first_solar_generation, get_last_solar_generation %}
            {%- from 'charge_battery_amount.jinja' import calculate_charge_battery_amount %}
            and will start at {{ as_timestamp(get_first_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'period_start', 'pv_estimate', 0.01))|timestamp_custom('%H:%M:%S') }}
            ({{ get_first_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'pv_estimate', 'pv_estimate', 0.01)|float(0)|round(2) }} kWh).
            {%- if not get_first_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'period_start', 'pv_estimate', avg_hourly_energy_usage)|default(None, true) %}
            The first self sustaining generation ({{ avg_hourly_energy_usage }} kWh) will occur at
            {{ as_timestamp(get_first_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'period_start', 'pv_estimate', avg_hourly_energy_usage))|timestamp_custom('%H:%M:%S') }}
            ({{ get_first_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'pv_estimate', 'pv_estimate', avg_hourly_energy_usage)|round(2) }} kWh).


            The last self sustaining generation of the day will be at
            {{ as_timestamp(get_last_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'period_start', 'pv_estimate', avg_hourly_energy_usage))|timestamp_custom('%H:%M:%S') }}
            ({{ get_last_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'pv_estimate', 'pv_estimate', avg_hourly_energy_usage)|round(2) }} kWh)
            finishing at
            {{ as_timestamp(get_last_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'period_start', 'pv_estimate', 0.01))|timestamp_custom('%H:%M:%S') }}
            ({{ get_last_solar_generation('sensor.solcast_pv_forecast_forecast_tomorrow', 'detailedForecast', 'pv_estimate', 'pv_estimate', 0.01)|round(2) }} kWh).
            {%- endif %}
            {%- else -%}
            {{ states('sensor.total_solar_forecast_estimated_energy_production_tomorrow')|float(0)|round(2) }}
            {{ state_attr('sensor.total_solar_forecast_estimated_energy_production_tomorrow','unit_of_measurement') }}.
            {%- endif %}


            The battery is {{ states('sensor.growatt_sph_battery_state_of_charge', with_unit=True) }} charged. The household load is
            {{ states('sensor.growatt_sph_load_power')|float(-1)|round(2) }} {{ state_attr('sensor.growatt_sph_load_power', 'unit_of_measurement') }}
            with an estimated run time of
            {{ as_timestamp(states('sensor.battery_charge_remaining_hours'))|timestamp_custom('%Y-%m-%d %H:%M:%S') }} ({{ state_attr('sensor.battery_charge_remaining_hours', 'duration') }}).


            Charge :house_with_garden::battery: battery to
            {{ solar_forecast_data.estimate_charge_percentage }}%
            ({{ solar_forecast_data.estimate_charge_kwh }} kWh).
            Charge time is {{ solar_forecast_data.charge_hours }} ({{ solar_forecast_data.charge_hours_rounded }}) hours
            ({{ (solar_forecast_data.charge_hours_rounded*2) }} slots).


            {%- if states('input_select.home_mode')|lower == 'holiday' %}
            Using daily average: {{ states('sensor.home_electricity_power_daily_average_over_a_day')|float(1) }}
            {%- endif %}
          title: ":sunny: :zap: Solar"
          people:
            entity_id:
              - person.danny
              - person.terina
  remaining_solar_forecast_today:
    variables:
      remaining: >-
        {
          'value':{{ (states('sensor.total_solar_forecast_estimated_energy_production_today')|float(0) - states('sensor.growatt_solar_generated_energy_today')|float(0))|round(2) }},
          'unit_of_measurement': '{{ state_attr('sensor.growatt_solar_generated_energy_today', 'unit_of_measurement') }}'
        }
    sequence:
      - stop: End
        response_variable: remaining
  get_first_solar_generation:
    alias: Get First Solar Generation
    fields:
      forecast_entity:
        description: The entity ID that has the forecast as an attribute.
        example: sensor.solcast_pv_forecast_forecast_tomorrow
        default: sensor.solcast_pv_forecast_forecast_tomorrow
        required: true
        selector:
          text:
      attribute_name:
        description: Attribute name containing the list of forecast information.
        example: detailedForecast
        default: detailedForecast
        required: true
        selector:
          text:
      get_atttribute:
        description: Attribute name of the value to return.
        example: period_start
        required: true
        selector:
          text:
      generation_attribute_name:
        description: Name of attribute containing the kWh generation.
        example: pv_estimate
        selector:
          text:
      min_generation:
        description: >-
          (Optional) first occurance above specified kWh.
          If not set then the first hour with any generation will be returned.
        selector:
          number:
            min: 0
            max: 50
            step: 0.01
            unit_of_measurement: kWh
    variables:
      solar: >-
        {%- set forecast = namespace(value=[]) -%}
        {%- for period in state_attr(forecast_entity, attribute_name) -%}
        {%- if period.get(generation_attribute_name|default('pv_estimate', true)) > min_generation|default(0, true) -%}
        {%- set forecast.value = period.get(get_atttribute) -%}
        {%- break -%}
        {%- endif -%}
        {%- endfor -%}
        {#- If no results were found, return None -#}
        {%- if get_atttribute == 'pv_estimate' -%}
        {{ 
        {
        'forecast': forecast.value|default(None, true)
        }
        }}
        {%- else -%}
        {{ 
        {
        'forecast': ""~forecast.value|default(None, true)~""
        }
        }}
        {%- endif -%}
    sequence:
      - stop: End
        response_variable: solar
  get_last_solar_generation:
    alias: Get Last Solar Generation
    fields:
      forecast_entity:
        description: The entity ID that has the forecast as an attribute.
        example: sensor.solcast_pv_forecast_forecast_tomorrow
        default: sensor.solcast_pv_forecast_forecast_tomorrow
        required: true
      attribute_name:
        description: Attribute name containing the list of forecast information.
        example: detailedForecast
        default: detailedForecast
        required: true
      get_atttribute:
        description: Attribute name of the value to return.
        example: period_start
        required: true
      generation_attribute_name:
        description: Name of attribute containing the kWh generation.
        example: pv_estimate
      min_generation:
        description: >-
          (Optional) first occurance above specified kWh.
          If not set then the first hour with any generation will be returned.
    variables:
      solar: >-
        {%- set forecast = namespace(value=[]) -%}
        {%- for period in state_attr(forecast_entity, attribute_name)|reverse -%}
        {%- if period.get(generation_attribute_name) > min_generation|default(0, true) -%}
        {%- set forecast.value = period.get(get_atttribute) -%}
        {%- break -%}
        {%- endif -%}
        {%- endfor -%}
        {#- If no results were found, return None -#}
        {%- if get_atttribute == 'pv_estimate' -%}
        {{ 
        {
        'forecast': forecast.value|default(None, true)
        }
        }}
        {%- else -%}
        {{ 
        {
        'forecast': ""~forecast.value|default(None, true)~""
        }
        }}
        {%- endif -%}
    sequence:
      - stop: End
        response_variable: solar

template:
  - trigger:
      - platform: state
        entity_id:
          - sensor.house_power
          - sensor.smart_meter_electricity_power
    sensor:
      - name: "Grid Import Power"
        unique_id: 09f48f73-ea68-421f-868c-ffd20cd8eab8
        state: >-
          {%- if states('sensor.house_power')|float(0) > 0 -%}
            {{ states('sensor.house_power')|float(0) }}
          {%- elif states('sensor.smart_meter_electricity_power')|float(0) > 0 -%}
            {{ states('sensor.smart_meter_electricity_power')|float(0) }}
          {%- else -%}
            0
          {%- endif -%}
        availability: "{{ states('sensor.house_power')|is_number or states('sensor.smart_meter_electricity_power')|is_number }}"
        device_class: "power"
        unit_of_measurement: "W"
        state_class: "measurement"
  - trigger:
      - platform: state
        entity_id:
          - sensor.house_power
          - sensor.smart_meter_electricity_power
    sensor:
      - name: "Grid Export Power"
        unique_id: ed52b9f5-fddd-4797-85a1-b4fb6df8cd0e
        state: >-
          {% if states('sensor.house_power')|float(0) < 0 -%}
            {{ states('sensor.house_power')|float(0)|abs }}
          {%- elif states('sensor.smart_meter_electricity_power')|float(0) < 0 -%}
            {{ states('sensor.smart_meter_electricity_power')|float(0)|abs }}
          {%- else -%}
            0
          {%- endif -%}
        availability: "{{ states('sensor.house_power')|is_number }}"
        device_class: "power"
        unit_of_measurement: "W"
        state_class: "measurement"
  - trigger:
      - platform: state
        entity_id:
          - input_number.cut_out_fuse_size
    sensor:
      - name: "Grid Amp Import Warning"
        unique_id: 02d4ee4e-967f-4b1a-80c1-a2b9dca61d01
        state: >-
          {{ states('input_number.cut_out_fuse_size')|float(100) * 0.9 }}
        availability: "{{ states('input_number.cut_out_fuse_size')|is_number }}"
        icon: mdi:fuse-alert
        unit_of_measurement: "A"
